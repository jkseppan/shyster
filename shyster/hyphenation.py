# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_hyphenation.ipynb.

# %% auto 0
__all__ = ['hyphenator']

# %% ../02_hyphenation.ipynb 3
import re
import itertools as it
from collections.abc import Sequence, Mapping, Iterable
from shyster.file import read_patterns
from shyster.pattern import convert_patterns, convert_exceptions
from pathlib import Path

# %% ../02_hyphenation.ipynb 5
def add_hyphens(
    s: str,  # word to hyphenate
    positions: Sequence[int],  # positions to insert hyphens (increasing order)
    hyphen: str='-'  # hyphen character
) -> str:  # word with hyphens
    i0, i1 = it.tee(iter(positions))
    i0 = it.chain((0,), i0)
    i1 = it.chain(i1, (len(s),))
    substrings = (s[p0:p1] for (p0,p1) in zip(i0, i1))
    return hyphen.join(substrings).strip(hyphen)

# %% ../02_hyphenation.ipynb 9
class hyphenator:
    """Hyphenates words"""
    __slots__ = ('regex', 'mapping', 'exceptions', 'hyphen', 'lefthyphenmin', 'righthyphenmin')
    regex: re.Pattern  # first return value from `pattern.convert_patterns`
    mapping: Mapping[str, tuple[int,...]]  # second return value from `pattern.convert_patterns`
    exceptions: Mapping[str, tuple[str,...]]  # return value from `pattern.convert_exceptions`
    hyphen: str  # hyphen character
    lefthyphenmin: int  # at least this many characters before the first hyphen
    righthyphenmin: int  # at least this many characters after the last hyphen

    def __init__(
        self,
        initializer: (str   # filename of hyphen.tex, or an iterable of its lines, or None
                      | Path
                      | Iterable[str]
                      | None),
        hyphen: str='-',
        lefthyphenmin: int=2,
        righthyphenmin: int=3,
    ):
        if initializer is None:
            # the user will set these up explicitly
            self.regex = re.compile('')
            self.mapping = {}
            self.exceptions = {}
        else:
            f = None
            if isinstance(initializer, (str, Path)):
                f = open(initializer, 'rt')
                it: Iterable[str] = f.readlines()
            elif isinstance(initializer, Iterable):
                it = initializer
            else:
                raise TypeError(f"don't know how to use {type(initializer)}")
            pat, exc = read_patterns(it)
            if f:
                f.close()
            self.regex, self.mapping = convert_patterns(pat)
            self.exceptions = convert_exceptions(exc)
            
        self.hyphen = hyphen
        self.lefthyphenmin = lefthyphenmin
        self.righthyphenmin = righthyphenmin
    
    def __call__(self, word: str):
        return self.hyphenate(word)
    
    def add_exception(
        self,
        word: str,  # word to add, possibly with `-` characters to indicate hyphenation points
        split: tuple[str,...] | None,  # how to split the word, or None to split at `-` characters
    ):
        if split is not None:
            self.exceptions.update(convert_exceptions([word]))
        else:
            self.exceptions[word] = split
    
    def rm_exception(
        self,
        word: str  # word to make unexceptional, without hyphens
    ):
        del self.exceptions[word]
        
    def hyphenate(self, word: str) -> str:
        if (result := self.exceptions.get(word)):
            return self.hyphen.join(result)
        word = f'\x1f{word}\x1f'
        weights = bytearray(len(word))
        for match in self.regex.finditer(word):
            pos = match.span()[0]-1
            key = match.group(1)
            rule = self.mapping[key]
            for i, w in enumerate(rule):
                weights[pos+i] = max(weights[pos+i], w)
        positions = [i for (i,w) in enumerate(weights)
                     if w&1==1 and i>=self.lefthyphenmin and i<=len(word)-2-self.righthyphenmin]
        return add_hyphens(word[1:-1], positions, hyphen=self.hyphen)

