# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_pattern.ipynb.

# %% auto 0
__all__ = ['convert_patterns', 'convert_exceptions']

# %% ../01_pattern.ipynb 3
import re, string
import itertools as it
from collections.abc import Iterable, Mapping

# %% ../01_pattern.ipynb 5
def _cvt(
    pattern: str  # pattern as read from the TeX patterns file
) -> tuple[int, ...]:  # position i has the weight of the slot before character i
    res = [0 for _ in pattern]
    pos = 0
    for ch in pattern:
        if ch in string.digits:
            res[pos] = int(ch)
        else:
            pos += 1
    return tuple(res[:pos+1])

# %% ../01_pattern.ipynb 8
def convert_patterns(
    patterns: Iterable[str]  # patterns as read from the TeX patterns file
) -> tuple[re.Pattern, Mapping[str, tuple[int, ...]]]:  # regex for patterns, and mapping from pattern to weights
    regexes = []
    mapping = {}
    for p in patterns:
        # replace dot with a control character unlikely to appear in words (ASCII unit separator)
        p = p.replace('.', '\x1f')
        s = re.sub('[0-9]', '', p)
        regexes.append(s)
        mapping[s] = _cvt(p)
    return re.compile(f"(?=({'|'.join(regexes)}))"), mapping

# %% ../01_pattern.ipynb 12
def convert_exceptions(
    exceptions: Iterable[str]
) -> Mapping[str, tuple[str,...]]:  # mapping from word to word parts
    return {w.replace('-', ''): tuple(w.split('-')) for w in exceptions}
